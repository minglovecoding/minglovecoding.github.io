---
title: leetcode hot100刷题笔记
date: 2025-05-30  11:36:28 
taxonomies:
  tags:
    - leetcode
---
- 3. 无重复字符的最长子串
给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。  
示例 1:  
输入: s = "abcabcbb"  
输出: 3   
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。  
> 左右双指针，注意set用法。
---
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        res=0
        n=len(s)
        set1=set()
        left=0
        for right in range(n):
            while s[right] in set1:
                set1.remove(s[left])
                left+=1
            set1.add(s[right])
            res=max(res,len(set1))
        return res

---

- 438. 找到字符串中所有字母异位词  
 给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。  
 示例 1:  
 输入: s = "cbaebabacd", p = "abc"  
 输出: [0,6]  
 解释:  
 起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。  
 起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。  

>该题的解题思路是首先用Counter计数器计算每个字符的出现次数,用left,right双指针依次在母串里迭代，每迭代一次对减速器进行-1操作，如果cnt_p[s[right]]<0,则移动左指针，并对cnt_p[s[left]]进行+1操作。当right-left+1等于len(p)时候，说明找到了该子串的起始索引。  

```
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        res=[]
        n=len(s)
        cnt_p=Counter(p)
        left=0
        for right in range(n):
            cnt_p[s[right]]-=1
            while cnt_p[s[right]]<0:
                cnt_p[s[left]]+=1
                left+=1
            if right-left+1==len(p):
                res.append(left)
        return res

```

