---
title: leetcode hot100刷题笔记
date: 2025-05-30  11:36:28 
taxonomies:
  tags:
    - leetcode
---

- 239.滑动窗口最大值
给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值 。
示例 1：  
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3  
输出：[3,3,5,5,6,7]  
解释：  
滑动窗口的位置                最大值  
---------------               -----  
[1  3  -1] -3  5  3  6  7       3  
 1 [3  -1  -3] 5  3  6  7       3  
 1  3 [-1  -3  5] 3  6  7       5  
 1  3  -1 [-3  5  3] 6  7       5  
 1  3  -1  -3 [5  3  6] 7       6  
 1  3  -1  -3  5 [3  6  7]      7  

>思路：deque双端队列递减存放窗口元素值。分两部分，首先是窗口未形成，这时一直在添加元素，deque只需对新加入的元素进行判断。如果小于deque最后的元素，直接添加，如果大于，deque逐个弹出尾部元素。当窗口形成后，还需考虑移走的元素是不是deque[0],如果是，需要deque.popleft()。

```
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        deque=collections.deque()
        res=[]
        n=len(nums)
        for i in range(k):
            while deque and deque[-1]<nums[i]:
                deque.pop()
            deque.append(nums[i])
        res.append(deque[0])

        for j in range(k,n):
            if deque[0]==nums[j-k]:
                deque.popleft()
            while deque and deque[-1]<nums[j]:
                deque.pop()
            deque.append(nums[j])
            res.append(deque[0])
        return res

```
- 560.和为K的子数组  
给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。
子数组是数组中元素的连续非空序列。  
示例 1：  
输入：nums = [1,1,1], k = 2  
输出：2  

> 思路：前缀和+哈希表，python哈希表是dic=defaultdict([数据类型])，逐个遍历每个前缀和，关键是在字典里找key为pre[i]-k的值。

```
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        res=0
        pre=[0]*(len(nums)+1)
        dic=defaultdict(int)
        n=len(nums)
        for i in range(n):
            pre[i+1]=pre[i]+nums[i]
        for j in pre:
            res+=dic[j-k]
            dic[j]+=1
        return res
```

- 3. 无重复字符的最长子串
给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。  
示例 1:  
输入: s = "abcabcbb"  
输出: 3   
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。  
> 思路：左右双指针，注意set用法。

```
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        res=0
        n=len(s)
        set1=set()
        left=0
        for right in range(n):
            while s[right] in set1:
                set1.remove(s[left])
                left+=1
            set1.add(s[right])
            res=max(res,len(set1))
        return res
```

- 438. 找到字符串中所有字母异位词  
 给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。  
 示例 1:  
 输入: s = "cbaebabacd", p = "abc"  
 输出: [0,6]  
 解释:  
 起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。  
 起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。  

>思路：该题的解题思路是首先用Counter计数器计算每个字符的出现次数,用left,right双指针依次在母串里迭代，每迭代一次对减速器进行-1操作，如果cnt_p[s[right]]<0,则移动左指针，并对cnt_p[s[left]]进行+1操作。当right-left+1等于len(p)时候，说明找到了该子串的起始索引。  

```
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        res=[]
        n=len(s)
        cnt_p=Counter(p)
        left=0
        for right in range(n):
            cnt_p[s[right]]-=1
            while cnt_p[s[right]]<0:
                cnt_p[s[left]]+=1
                left+=1
            if right-left+1==len(p):
                res.append(left)
        return res

```

